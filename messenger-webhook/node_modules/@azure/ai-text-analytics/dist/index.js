'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');
var api = require('@opentelemetry/api');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "1.0.0-preview.5";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const MultiLanguageInput = {
    serializedName: "MultiLanguageInput",
    type: {
        name: "Composite",
        className: "MultiLanguageInput",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            text: {
                required: true,
                serializedName: "text",
                type: {
                    name: "String"
                }
            },
            language: {
                serializedName: "language",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MultiLanguageBatchInput = {
    serializedName: "MultiLanguageBatchInput",
    type: {
        name: "Composite",
        className: "MultiLanguageBatchInput",
        modelProperties: {
            documents: {
                required: true,
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MultiLanguageInput"
                        }
                    }
                }
            }
        }
    }
};
const InnerError = {
    serializedName: "InnerError",
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                required: true,
                serializedName: "code",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "InvalidParameterValue",
                        "InvalidRequestBodyFormat",
                        "EmptyRequest",
                        "MissingInputRecords",
                        "InvalidDocument",
                        "ModelVersionIncorrect",
                        "InvalidDocumentBatch",
                        "UnsupportedLanguageCode",
                        "InvalidCountryHint"
                    ]
                }
            },
            message: {
                required: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const TextAnalyticsError = {
    serializedName: "TextAnalyticsError",
    type: {
        name: "Composite",
        className: "TextAnalyticsError",
        modelProperties: {
            code: {
                required: true,
                serializedName: "code",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "InvalidRequest",
                        "InvalidArgument",
                        "InternalServerError",
                        "ServiceUnavailable"
                    ]
                }
            },
            message: {
                required: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            }
        }
    }
};
const DocumentError = {
    serializedName: "DocumentError",
    type: {
        name: "Composite",
        className: "DocumentError",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            error: {
                required: true,
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TextAnalyticsError"
                }
            }
        }
    }
};
const TextAnalyticsWarning = {
    serializedName: "TextAnalyticsWarning",
    type: {
        name: "Composite",
        className: "TextAnalyticsWarning",
        modelProperties: {
            code: {
                required: true,
                serializedName: "code",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "LongWordsInDocument",
                        "DocumentTruncated"
                    ]
                }
            },
            message: {
                required: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TextDocumentStatistics = {
    serializedName: "TextDocumentStatistics",
    type: {
        name: "Composite",
        className: "TextDocumentStatistics",
        modelProperties: {
            characterCount: {
                required: true,
                serializedName: "charactersCount",
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                required: true,
                serializedName: "transactionsCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentimentConfidenceScores = {
    serializedName: "SentimentConfidenceScores",
    type: {
        name: "Composite",
        className: "SentimentConfidenceScores",
        modelProperties: {
            positive: {
                required: true,
                serializedName: "positive",
                type: {
                    name: "Number"
                }
            },
            neutral: {
                required: true,
                serializedName: "neutral",
                type: {
                    name: "Number"
                }
            },
            negative: {
                required: true,
                serializedName: "negative",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentenceSentiment = {
    serializedName: "SentenceSentiment",
    type: {
        name: "Composite",
        className: "SentenceSentiment",
        modelProperties: {
            text: {
                serializedName: "text",
                type: {
                    name: "String"
                }
            },
            sentiment: {
                required: true,
                serializedName: "sentiment",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "positive",
                        "neutral",
                        "negative"
                    ]
                }
            },
            confidenceScores: {
                required: true,
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            }
        }
    }
};
const DocumentSentiment = {
    serializedName: "DocumentSentiment",
    type: {
        name: "Composite",
        className: "DocumentSentiment",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            sentiment: {
                required: true,
                serializedName: "sentiment",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "positive",
                        "neutral",
                        "negative",
                        "mixed"
                    ]
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            },
            confidenceScores: {
                required: true,
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            sentenceSentiments: {
                required: true,
                serializedName: "sentences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceSentiment"
                        }
                    }
                }
            },
            warnings: {
                required: true,
                serializedName: "warnings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            }
        }
    }
};
const TextDocumentBatchStatistics = {
    serializedName: "TextDocumentBatchStatistics",
    type: {
        name: "Composite",
        className: "TextDocumentBatchStatistics",
        modelProperties: {
            documentCount: {
                required: true,
                serializedName: "documentsCount",
                type: {
                    name: "Number"
                }
            },
            validDocumentCount: {
                required: true,
                serializedName: "validDocumentsCount",
                type: {
                    name: "Number"
                }
            },
            erroneousDocumentCount: {
                required: true,
                serializedName: "erroneousDocumentsCount",
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                required: true,
                serializedName: "transactionsCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentimentResponse = {
    serializedName: "SentimentResponse",
    type: {
        name: "Composite",
        className: "SentimentResponse",
        modelProperties: {
            documents: {
                required: true,
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSentiment"
                        }
                    }
                }
            },
            errors: {
                required: true,
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                required: true,
                serializedName: "modelVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Entity = {
    serializedName: "Entity",
    type: {
        name: "Composite",
        className: "Entity",
        modelProperties: {
            text: {
                required: true,
                serializedName: "text",
                type: {
                    name: "String"
                }
            },
            category: {
                required: true,
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            subCategory: {
                serializedName: "subcategory",
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                required: true,
                serializedName: "confidenceScore",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentEntities = {
    serializedName: "DocumentEntities",
    type: {
        name: "Composite",
        className: "DocumentEntities",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            entities: {
                required: true,
                serializedName: "entities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Entity"
                        }
                    }
                }
            },
            warnings: {
                required: true,
                serializedName: "warnings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const EntitiesResult = {
    serializedName: "EntitiesResult",
    type: {
        name: "Composite",
        className: "EntitiesResult",
        modelProperties: {
            documents: {
                required: true,
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentEntities"
                        }
                    }
                }
            },
            errors: {
                required: true,
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                required: true,
                serializedName: "modelVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Match = {
    serializedName: "Match",
    type: {
        name: "Composite",
        className: "Match",
        modelProperties: {
            confidenceScore: {
                required: true,
                serializedName: "confidenceScore",
                type: {
                    name: "Number"
                }
            },
            text: {
                required: true,
                serializedName: "text",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LinkedEntity = {
    serializedName: "LinkedEntity",
    type: {
        name: "Composite",
        className: "LinkedEntity",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            matches: {
                required: true,
                serializedName: "matches",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Match"
                        }
                    }
                }
            },
            language: {
                required: true,
                serializedName: "language",
                type: {
                    name: "String"
                }
            },
            dataSourceEntityId: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            url: {
                required: true,
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            dataSource: {
                required: true,
                serializedName: "dataSource",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentLinkedEntities = {
    serializedName: "DocumentLinkedEntities",
    type: {
        name: "Composite",
        className: "DocumentLinkedEntities",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            entities: {
                required: true,
                serializedName: "entities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LinkedEntity"
                        }
                    }
                }
            },
            warnings: {
                required: true,
                serializedName: "warnings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const EntityLinkingResult = {
    serializedName: "EntityLinkingResult",
    type: {
        name: "Composite",
        className: "EntityLinkingResult",
        modelProperties: {
            documents: {
                required: true,
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLinkedEntities"
                        }
                    }
                }
            },
            errors: {
                required: true,
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                required: true,
                serializedName: "modelVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentKeyPhrases = {
    serializedName: "DocumentKeyPhrases",
    type: {
        name: "Composite",
        className: "DocumentKeyPhrases",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            keyPhrases: {
                required: true,
                serializedName: "keyPhrases",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            warnings: {
                required: true,
                serializedName: "warnings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const KeyPhraseResult = {
    serializedName: "KeyPhraseResult",
    type: {
        name: "Composite",
        className: "KeyPhraseResult",
        modelProperties: {
            documents: {
                required: true,
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentKeyPhrases"
                        }
                    }
                }
            },
            errors: {
                required: true,
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                required: true,
                serializedName: "modelVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LanguageInput = {
    serializedName: "LanguageInput",
    type: {
        name: "Composite",
        className: "LanguageInput",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            text: {
                required: true,
                serializedName: "text",
                type: {
                    name: "String"
                }
            },
            countryHint: {
                serializedName: "countryHint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LanguageBatchInput = {
    serializedName: "LanguageBatchInput",
    type: {
        name: "Composite",
        className: "LanguageBatchInput",
        modelProperties: {
            documents: {
                required: true,
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LanguageInput"
                        }
                    }
                }
            }
        }
    }
};
const DetectedLanguage = {
    serializedName: "DetectedLanguage",
    type: {
        name: "Composite",
        className: "DetectedLanguage",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            iso6391Name: {
                required: true,
                serializedName: "iso6391Name",
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                required: true,
                serializedName: "confidenceScore",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentLanguage = {
    serializedName: "DocumentLanguage",
    type: {
        name: "Composite",
        className: "DocumentLanguage",
        modelProperties: {
            id: {
                required: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            detectedLanguage: {
                required: true,
                serializedName: "detectedLanguage",
                type: {
                    name: "Composite",
                    className: "DetectedLanguage"
                }
            },
            warnings: {
                required: true,
                serializedName: "warnings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const LanguageResult = {
    serializedName: "LanguageResult",
    type: {
        name: "Composite",
        className: "LanguageResult",
        modelProperties: {
            documents: {
                required: true,
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLanguage"
                        }
                    }
                }
            },
            errors: {
                required: true,
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                required: true,
                serializedName: "modelVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MultiLanguageInput: MultiLanguageInput,
    MultiLanguageBatchInput: MultiLanguageBatchInput,
    InnerError: InnerError,
    TextAnalyticsError: TextAnalyticsError,
    DocumentError: DocumentError,
    TextAnalyticsWarning: TextAnalyticsWarning,
    TextDocumentStatistics: TextDocumentStatistics,
    SentimentConfidenceScores: SentimentConfidenceScores,
    SentenceSentiment: SentenceSentiment,
    DocumentSentiment: DocumentSentiment,
    TextDocumentBatchStatistics: TextDocumentBatchStatistics,
    SentimentResponse: SentimentResponse,
    Entity: Entity,
    DocumentEntities: DocumentEntities,
    EntitiesResult: EntitiesResult,
    Match: Match,
    LinkedEntity: LinkedEntity,
    DocumentLinkedEntities: DocumentLinkedEntities,
    EntityLinkingResult: EntityLinkingResult,
    DocumentKeyPhrases: DocumentKeyPhrases,
    KeyPhraseResult: KeyPhraseResult,
    LanguageInput: LanguageInput,
    LanguageBatchInput: LanguageBatchInput,
    DetectedLanguage: DetectedLanguage,
    DocumentLanguage: DocumentLanguage,
    LanguageResult: LanguageResult
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        required: true,
        serializedName: "Endpoint",
        defaultValue: '',
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const includeStatistics = {
    parameterPath: [
        "options",
        "includeStatistics"
    ],
    mapper: {
        serializedName: "showStats",
        type: {
            name: "Boolean"
        }
    }
};
const modelVersion = {
    parameterPath: [
        "options",
        "modelVersion"
    ],
    mapper: {
        serializedName: "model-version",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const packageName = "@azure/ai-text-analytics";
const packageVersion = "1.0.0-preview.5";
class GeneratedClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClientContext class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus.api.cognitive.microsoft.com).
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param [options] The parameter options
     */
    constructor(credentials, endpoint, options) {
        if (endpoint == undefined) {
            throw new Error("'endpoint' cannot be null.");
        }
        if (credentials == undefined) {
            throw new Error("'credentials' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(credentials, options);
        this.baseUri = "{Endpoint}/text/analytics/v3.0";
        this.requestContentType = "application/json; charset=utf-8";
        this.endpoint = endpoint;
        this.credentials = credentials;
    }
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://westus.api.cognitive.microsoft.com).
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param [options] The parameter options
     */
    constructor(credentials, endpoint, options) {
        super(credentials, endpoint, options);
    }
    entitiesRecognitionGeneral(input, options, callback) {
        return this.sendOperationRequest({
            input,
            options
        }, entitiesRecognitionGeneralOperationSpec, callback);
    }
    entitiesLinking(input, options, callback) {
        return this.sendOperationRequest({
            input,
            options
        }, entitiesLinkingOperationSpec, callback);
    }
    keyPhrases(input, options, callback) {
        return this.sendOperationRequest({
            input,
            options
        }, keyPhrasesOperationSpec, callback);
    }
    languages(input, options, callback) {
        return this.sendOperationRequest({
            input,
            options
        }, languagesOperationSpec, callback);
    }
    sentiment(input, options, callback) {
        return this.sendOperationRequest({
            input,
            options
        }, sentimentOperationSpec, callback);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers);
const entitiesRecognitionGeneralOperationSpec = {
    httpMethod: "POST",
    path: "entities/recognition/general",
    urlParameters: [
        endpoint
    ],
    queryParameters: [
        modelVersion,
        includeStatistics
    ],
    requestBody: {
        parameterPath: "input",
        mapper: Object.assign(Object.assign({}, MultiLanguageBatchInput), { required: true })
    },
    responses: {
        200: {
            bodyMapper: EntitiesResult
        },
        default: {
            bodyMapper: TextAnalyticsError
        }
    },
    serializer
};
const entitiesLinkingOperationSpec = {
    httpMethod: "POST",
    path: "entities/linking",
    urlParameters: [
        endpoint
    ],
    queryParameters: [
        modelVersion,
        includeStatistics
    ],
    requestBody: {
        parameterPath: "input",
        mapper: Object.assign(Object.assign({}, MultiLanguageBatchInput), { required: true })
    },
    responses: {
        200: {
            bodyMapper: EntityLinkingResult
        },
        default: {
            bodyMapper: TextAnalyticsError
        }
    },
    serializer
};
const keyPhrasesOperationSpec = {
    httpMethod: "POST",
    path: "keyPhrases",
    urlParameters: [
        endpoint
    ],
    queryParameters: [
        modelVersion,
        includeStatistics
    ],
    requestBody: {
        parameterPath: "input",
        mapper: Object.assign(Object.assign({}, MultiLanguageBatchInput), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyPhraseResult
        },
        default: {
            bodyMapper: TextAnalyticsError
        }
    },
    serializer
};
const languagesOperationSpec = {
    httpMethod: "POST",
    path: "languages",
    urlParameters: [
        endpoint
    ],
    queryParameters: [
        modelVersion,
        includeStatistics
    ],
    requestBody: {
        parameterPath: "input",
        mapper: Object.assign(Object.assign({}, LanguageBatchInput), { required: true })
    },
    responses: {
        200: {
            bodyMapper: LanguageResult
        },
        default: {
            bodyMapper: TextAnalyticsError
        }
    },
    serializer
};
const sentimentOperationSpec = {
    httpMethod: "POST",
    path: "sentiment",
    urlParameters: [
        endpoint
    ],
    queryParameters: [
        modelVersion,
        includeStatistics
    ],
    requestBody: {
        parameterPath: "input",
        mapper: Object.assign(Object.assign({}, MultiLanguageBatchInput), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SentimentResponse
        },
        default: {
            bodyMapper: TextAnalyticsError
        }
    },
    serializer
};

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("ai-text-analytics");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper function for converting nested service error into
 * the unified TextAnalyticsError
 */
function intoTextAnalyticsError(errorModel) {
    // Return the deepest error. This will always be at most
    // one level for TextAnalytics
    if (errorModel.innerError !== undefined) {
        return intoTextAnalyticsError(errorModel.innerError);
    }
    return {
        code: errorModel.code,
        message: errorModel.message,
        target: errorModel.target
    };
}
function makeTextAnalyticsSuccessResult(id, warnings, statistics) {
    return {
        id,
        statistics,
        warnings
    };
}
function makeTextAnalyticsErrorResult(id, error) {
    return {
        id,
        error: intoTextAnalyticsError(error)
    };
}

// Copyright (c) Microsoft Corporation.
function makeDetectLanguageResult(id, detectedLanguage, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { primaryLanguage: detectedLanguage });
}
function makeDetectLanguageErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function isGenericError(o) {
    return o.id === "";
}
/**
 * Given a sorted array of input objects (with a unique ID) and an unsorted array of results,
 * return a sorted array of results.
 *
 * If a generic error (id = "") occurred in the response, this function will throw it
 * as an exception.
 *
 * @ignore
 * @param sortedArray An array of entries sorted by `id`
 * @param unsortedArray An array of entries that contain `id` but are not sorted
 */
function sortResponseIdObjects(sortedArray, unsortedArray) {
    const unsortedMap = new Map();
    for (const item of unsortedArray) {
        if (isGenericError(item)) {
            throw new coreHttp.RestError(item.error.message, item.error.code, 400);
        }
        unsortedMap.set(item.id, item);
    }
    if (unsortedArray.length !== sortedArray.length) {
        const ordinal = unsortedArray.length > sortedArray.length ? "more" : "fewer";
        logger.warning(`The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`);
    }
    return sortedArray.map((item) => unsortedMap.get(item.id));
}

// Copyright (c) Microsoft Corporation.
function makeDetectLanguageResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeDetectLanguageResult(document.id, document.detectedLanguage, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeDetectLanguageErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeCategorizedEntitiesResult(id, entities, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
function makeRecognizeCategorizedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeCategorizedEntitiesResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeRecognizeCategorizedEntitiesResult(document.id, document.entities, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeRecognizeCategorizedEntitiesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeAnalyzeSentimentResult(id, sentiment, confidenceScores, sentences, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { sentiment,
        confidenceScores,
        sentences });
}
function makeAnalyzeSentimentErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeAnalyzeSentimentResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeAnalyzeSentimentResult(document.id, document.sentiment, document.confidenceScores, document.sentenceSentiments, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeAnalyzeSentimentErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeExtractKeyPhrasesResult(id, keyPhrases, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { keyPhrases });
}
function makeExtractKeyPhrasesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeExtractKeyPhrasesResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeExtractKeyPhrasesResult(document.id, document.keyPhrases, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeExtractKeyPhrasesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeLinkedEntitiesResult(id, entities, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
function makeRecognizeLinkedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeLinkedEntitiesResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeRecognizeLinkedEntitiesResult(document.id, document.entities, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeRecognizeLinkedEntitiesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @ignore
 * @param name The name of the operation being performed.
 * @param tracingOptions The options for the underlying http request.
 */
function createSpan(operationName, operationOptions) {
    const tracer = coreTracing.getTracer();
    const tracingOptions = operationOptions.tracingOptions || {};
    const spanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { kind: api.SpanKind.INTERNAL });
    const span = tracer.startSpan(`Azure.CognitiveServices.TextAnalytics.${operationName}`, spanOptions);
    span.setAttribute("az.namespace", "Microsoft.CognitiveServices");
    let newSpanOptions = tracingOptions.spanOptions || {};
    if (span.isRecording()) {
        newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.CognitiveServices" }) });
    }
    const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), { spanOptions: newSpanOptions });
    const newOperationOptions = Object.assign(Object.assign({}, operationOptions), { tracingOptions: newTracingOptions });
    return {
        span,
        updatedOptions: newOperationOptions
    };
}

// Copyright (c) Microsoft Corporation.
const API_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Text Analytics
 */
function createTextAnalyticsAzureKeyCredentialPolicy(credential) {
    return {
        create: (nextPolicy, options) => {
            return new TextAnalyticsAzureKeyCredentialPolicy(nextPolicy, options, credential);
        }
    };
}
/**
 * A concrete implementation of an AzureKeyCredential policy
 * using the appropriate header for TextAnalytics
 */
class TextAnalyticsAzureKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, credential) {
        super(nextPolicy, options);
        this.credential = credential;
    }
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!webResource) {
                throw new Error("webResource cannot be null or undefined");
            }
            webResource.headers.set(API_KEY_HEADER_NAME, this.credential.key);
            return this._nextPolicy.sendRequest(webResource);
        });
    }
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
/**
 * Client class for interacting with Azure Text Analytics.
 */
class TextAnalyticsClient {
    /**
     * Creates an instance of TextAnalyticsClient.
     *
     * Example usage:
     * ```ts
     * import { TextAnalyticsClient, AzureKeyCredential } from "@azure/ai-text-analytics";
     *
     * const client = new TextAnalyticsClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param {string} endpointUrl The URL to the TextAnalytics endpoint
     * @param {TokenCredential | KeyCredential} credential Used to authenticate requests to the service.
     * @param {TextAnalyticsClientOptions} [options] Used to configure the TextAnalytics client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const { defaultCountryHint = "us", defaultLanguage = "en" } = options, pipelineOptions = tslib.__rest(options, ["defaultCountryHint", "defaultLanguage"]);
        this.defaultCountryHint = defaultCountryHint;
        this.defaultLanguage = defaultLanguage;
        const libInfo = `azsdk-js-ai-textanalytics/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? coreHttp.bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : createTextAnalyticsAzureKeyCredentialPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: ["x-ms-correlation-request-id", "x-ms-request-id"]
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        // The contract with the generated client requires a credential, even though it is never used
        // when a pipeline is provided. Until that contract can be changed, this dummy credential will
        // throw an error if the client ever attempts to use it.
        const dummyCredential = {
            signRequest() {
                throw new Error("Internal error: Attempted to use credential from service client, but a pipeline was provided.");
            }
        };
        this.client = new GeneratedClient(dummyCredential, this.endpointUrl, pipeline);
    }
    detectLanguage(documents, countryHintOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const countryHint = countryHintOrOptions || this.defaultCountryHint;
                realInputs = convertToDetectLanguageInput(documents, countryHint);
                realOptions = options || {};
            }
            else {
                // Replace "none" hints with ""
                realInputs = documents.map((input) => (Object.assign(Object.assign({}, input), { countryHint: input.countryHint === "none" ? "" : input.countryHint })));
                realOptions = countryHintOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-detectLanguages", realOptions);
            try {
                const result = yield this.client.languages({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                return makeDetectLanguageResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeEntities(documents, languageOrOptions, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeEntities", realOptions);
            try {
                const result = yield this.client.entitiesRecognitionGeneral({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                return makeRecognizeCategorizedEntitiesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    analyzeSentiment(documents, languageOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-analyzeSentiment", realOptions);
            try {
                const result = yield this.client.sentiment({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                return makeAnalyzeSentimentResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    extractKeyPhrases(documents, languageOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-extractKeyPhrases", realOptions);
            try {
                const result = yield this.client.keyPhrases({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                return makeExtractKeyPhrasesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeLinkedEntities(documents, languageOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeLinkedEntities", realOptions);
            try {
                const result = yield this.client.entitiesLinking({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                return makeRecognizeLinkedEntitiesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
}
function isStringArray(documents) {
    return typeof documents[0] === "string";
}
function convertToDetectLanguageInput(inputs, countryHint) {
    if (countryHint === "none") {
        countryHint = "";
    }
    return inputs.map((text, index) => {
        return {
            id: String(index),
            countryHint,
            text
        };
    });
}
function convertToTextDocumentInput(inputs, language) {
    return inputs.map((text, index) => {
        return {
            id: String(index),
            language,
            text
        };
    });
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.AzureKeyCredential;
    }
});
exports.TextAnalyticsClient = TextAnalyticsClient;
//# sourceMappingURL=index.js.map
